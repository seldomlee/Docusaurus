---
id: 正则表达式
title: 学习正则表达式的一些笔记
sidebar_label: 正则表达式
slug: /
---

<!-- more -->

## 前言

emmm虽然正则表达式好像不是特别急需，但后面还是需要学的=-=，就在吃喝玩乐睡的假期抽空学习一下。
本章是阅读《正则表达式30分钟入门》的笔记

## 界定符

指定正则表达式的开始和结束，可以当成是计算机语言中的大括号`{`和`}`。一般有三种表现方式：

- 斜杠。例如`/[0-9]/`。这是最常用的方式，在PHP中，推荐使用这种方式。
- 井号。例如`#[0-9]`。
- 大括号。例如`{[0-9]}`。在正则表达式中，大括号还有其他作用，所以这种方式不推荐使用。

## 修饰符 | 修正模式

给正则表达式的匹配过程添加一种匹配模式，一般加在屁股比如：`/[a-z]/i`

- `U` 加`U`是懒惰匹配，不加`U`是默认的贪婪匹配。
- `i` 忽略英文字母大小写。
- `x` 忽略空白。（包括空格和按tab键输出的制表符）
- `s` 让元字符`.`匹配包括换行符在内的所有字符。
- `A`强制从目标字符串开头匹配
- `e` `preg_replace()`在替换字符串中对逆向引用作正常的替换。简单的说，就是PHP会把replace的结果当做PHP代码。（替换字符串要符合php的语法规范）
  例如：`echo preg_replace('/(\d+),(\d+)/e', '$1+$2', '2,3');`会输出`5`
- `g`全局匹配(但只匹单行)
  若不带g，正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功并返回
  若带g，则字符串从左到右，找到每个符合条件的都记录下来，直到字符串结尾位置
- `m`多行匹配：若存在换行`\n`并且有开始`^`或结束`$`符的情况下，和`g`一起使用实现全局匹配。
  存在换行时默认会把换行符作为一个字符任务匹配。
  g只匹配第一行，添加m之后实现多行，每个换行符之后作为新的匹配起始

## 元字符

`.` ：匹配除换行符以外的任意字符
`\w`：匹配字母或数字或下划线或汉字等
`\s`：匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格 等
`\d`：匹配一位数字
`\b`：匹配单词的开始或结束。匹配这样一个位置：它的前一个字符和后一个字符不全是\w（一个是，一个不是或不存在）
`^`：匹配字符串开始
`$`：匹配字符串结束
`(`和`)`：小括号有很多妙用，看下面吧

## 反义

`\W` 匹配任意不是字母，数字，下划线，汉字的字符 
`\S` 匹配任意不是空白符的字符 
`\D` 匹配任意非数字的字符 
`\B` 匹配不是单词开头或结束的位置 
`[\^x]` 匹配除了x以外的任意字符 
`[\^aeiou]` 匹配除了aeiou这几个字母以外的任意字符

## 量词

`*` ：任意数量；重复0次或很多次
`+`：>=1次；重复1次或很多次
`?`：0 or 1；重复0次或1次
`{n}`：n次；如：\d{2}（表示\d重复匹配2次）；
`{n,}`：>=n次；重复n次或更多次
`{n,m}`：重复n到m次；重复次数不少于n，不大于m

## 字符转义

若需要查找元字符本身如`.`、`*`这些，需要用`\`来将这些字符的特殊意义取消掉：如`\.`、`\*`；当然查找`\`本身也需要转义为`\\`

## 正则表达式字符类备忘单

打ctf的时候碰到的正则匹配
ps：不过这个好像不是所有语言都适用？在使用正则测试小工具测试payload的时候就没能识别

`[:alpha:]`任意字母, `[A-Za-z]`
`[:upper:]`任意大写字母, `[A-Z]`
`[:lower:]`任意小写字母, `[a-z]`
`[:digit:]`任意数字, `[0-9]`
`[:alnum:]`任意字符字母数字,  `[A-Za-z0-9]`
`[:xdigit:]`任意十六进制数字, `[0-9A-Fa-f]`
`[:space:]`制表符，换行符，垂直制表符，换页，回车或空格
`[:blank:]`空格或制表符
`[:print:]`任意可打印字符
`[:punct:]`任意标点符号: `! ' # S % & ' ( ) * + , - . / : ; < = > ? @ [ / ] ^ _ { | } ~`
`[:graph:]`除space类之外的任意字符
`[:word:]`字母数字字符和下划线的连续字符串
`[:ascii:]`ASCII字符，范围：0-127
`[:cntrl:]`任何不属于字符类的字符: `[:upper:], [:lower:], [:alpha:], [:digit:], [:punct:], [:graph:], [:print:], [:xdigit:]`

## 查找字符类

如查找abcde，只需在方括号中列出`[abcde]`;那么就构造了这样一个只会匹配abcde的字符集，数量由其后的重复次数决定

也可以指定范围：
[0-9] 代表的含意与 \d 就是完全一致的：一位 数字；
[a-z0-9A-Z_] 也完全等同于 \w （如果只考虑英文的话）。

## 分支条件

正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都会进行匹配，具体方法是用 `|` 把不同的规则分隔开。如a | b，只要满足其中之一，都会进行匹配

## 分组(子表达式)

想要重复多个字符时，需要先用小括号进行分组，然后再指定这个分组的重复次数。
eg：
`(\d{1,3}\.){3}\d{1,3}`
是一个简单的 IP 地址匹配表达式。
按下列顺序分析它：
` \d{1,3} `匹配 1到3位的数字，
 `(\d{1,3}\.){3} `匹配三位数字加上一个英文句号(这个整体也就是这个分组) 重复3次，
最后再加上一个一到三位的数字 `(\d{1,3})` 。

IP地址中每个数字都不能大于255 且 01.02.03.04 这样前面带有0的数字, 也是正确的IP地址，IP 地址里的数字可以包含有前导 0 (leading zeroes). 
不过上述正则表达式也会匹配 256.300.888.999 这种不可能存在的IP地址。
如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能
所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：
`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

理解这个表达式的关键是理解 `2[0-4]\d|25[0-5]|[01]?\d\d?`



解析：分成三部分：`2[0-4]\d`、`25[0-5]`、`[01]?\d\d?`
`2[0-4]\d`：**2** + **[0-4]中的任一个** + **任意数字**；即：200-209、210-219、220-229、230-239、240-249
`25[0-5]：`：**25** + **[0-5]任一个**；即：250-255
`[01]?\d\d?：`：**[01]?**  +  **\d**  +  **\d?**;即0/1(不匹配或匹配1次)，加上任一数字，加上任一数字(不匹配或匹配1次)




## 后向引用

使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。
也就是说可以对分组匹配到的文字进行处理

默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

后向引用用于重复搜索前面某个分组匹配的文本。
例如：
 `\1` 代表分组1匹配的文本。
示例： `\b(\w+)\b\s+\1\b`  就可以可以用来匹配重复的单词，像go go, 或者kitty kitty。

解析：
`(\b(\w+)\b)` :首先是一个单词（这个单词会被捕获到编号为1的分组中），也就是单词开始处和结束处之间数量多于一个的字母或数字
`(\s+)` ：然后是1个或几个空白符 
 `(\1)` ：最后是分组1中捕获的内容（也就是前面匹配的那个单词）

### 自定义子表达式的组名

子表达式的组名也可以自己定义：

使用语法形如： `(? <Word>\w+)` (或者把尖括号换成'也行： `(?'Word'\w+)`) 
这样就把 `\w+` 的组名指定为 `Word` 了。

反向引用时：`\k<Word>`

由此可以将上面的例子`\b(\w+)\b\s+\1\b`写为`\b(?<Word>\w+)\b\s+\k<Word>\b`

### 使用 () 的一些常用的特定语法

| 分类     |     代码**/**语法      |                             说明                             |
| -------- | :--------------------: | :----------------------------------------------------------: |
| 捕获     |         (exp)          |            匹配exp,并捕获文本到**自动命名**的组里            |
|          | (?exp) or (?'name'exp) |             匹配exp,并捕获文本到名称为name的组里             |
|          |        (?:exp)         |    匹配exp,**不捕获**匹配的文本，也**不给此分组分配组号**    |
| 零宽断言 |        (?=exp)         |                    匹配**exp前面**的位置                     |
|          |        (?<=exp)        |                    匹配**exp后面**的位置                     |
|          |        (?!exp)         |              匹配**后面**跟的**不是exp**的位置               |
|          |        (?<!exp)        |                  匹配**前面不是exp**的位置                   |
| 注释     |      (?\#comment)      | 这种类型的分组不对正则表达式的处理产生任何影响，用于**提供注释**让人阅读 |



## 零宽断言

就是用于查找在某些内容(不包括这些内容)之前或之后的东西，即指定内容前/后的位置，并且该位置需满足一定条件（断言）；故综合称之为零宽断言。

`(?=exp)`（零宽度**正**预测**先行**断言）：断言自身出现的位置的**后面**能匹配表达式exp

> 比如：`\b\w+(?=ing\b)`，匹配**以ing结尾**的单词的前面部分(**除了ing以外的部分**)，
>
> 如查找*I'm singing while you're dancing.*时，它会匹配**sing**和**danc**。

`(?<=exp)`（零宽度**正**回顾**后发**断言）：断言自身出现的位置的**前面**能匹配表达式 exp

> 比如：`(?<=\bre)\w+\b`会匹配**以re开头**的单词的后半部分(**除了re以外的部分**)，
>
> 例如在查找*reading a book*时，它匹配**ading**。

## 负向零宽断言

`(?!exp)`（零宽度**负**预测**先行**断言）：断言此位置的**后面不能匹配**表达式exp

> 比如：
>
> `\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；
>
> `\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词。

`(?<!exp)`（零宽度**负**回顾**后发**断言）：断言此位置的**前面不能匹配**表达式exp

> 比如：
>
> `(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。
>
> `(?<=<(\w+)>).*(?=<\/\1>)`匹配不包含属性的简单HTML标签内里的内容
>
> 解析：
> `(?<=<(\w+)>)`指定了**前缀**：被尖括号括起来的单词(比如可能是`<b>`)，
> `.` `*`(任意的字符串),最后是一个**后缀**`(?=<\/\1>)`。
> 后缀里的`\/`用到了前面提过的字符转义；
> `\1`是一个反向引用，引用捕获的第一组，前面 `(\w+)` 匹配的内容
>
> 这样如果前缀实际上是 `<b>` 的话，后缀就是 `</b>` 了。
>
> 整个表达式匹配的是 `<b>` 和 `</b>` 之间的内容(不包括前缀和后缀本身)。
>
> 



## 注释

通过语法`(?#comment)`来包含注释

> 比如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`

要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。
启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。

例如，我们可以将前面的一个表达式写成这样：

```
  (?<=    # 断言要匹配的文本的前缀
  <(\w+)> # 查找尖括号括起来的内容
          # (即HTML/XML标签)
  )       # 前缀结束
  .*      # 匹配任意文本
  (?=     # 断言要匹配的文本的后缀
  <\/\1>  # 查找尖括号括起来的内容
          # 查找尖括号括起来的内容
  )       # 后缀结束
```






## 贪婪与懒惰

### 贪婪匹配

当正则表达式中包含能接受重复的限定符时，通常的行为是匹配尽可能多的字符（在使整个表达式能得到匹配的前提下）

如：`a.*b`会匹配最长的  以a开始，b结束  的字符串；
当以此对aabab进行搜索，就会匹配整个字符串aabab





### 懒惰匹配

也就是是匹配尽可能少的字符。
只需在限定符后加上`?`即可转换为懒惰匹配模式

如`a.*?b`匹配最短的  以a开始，b结束  的字符串；
当以此对aabab进行搜索，就会匹配aab和ab



#### 懒惰限定符：

| 代码**/**语法 | 说明                            |
| ------------- | :------------------------------ |
| *?            | 重复任意次，但尽可能少重复      |
| +?            | 重复1次或更多次，但尽可能少重复 |
| ??            | 重复0次或1次，但尽可能少重复    |
| {n,m}?        | 重复n到m次，但尽可能少重复      |
| {n,}?         | 重复n次以上，但尽可能少重复     |



## 处理选项（基于python）

Python 中常用的正则表达式选项（用到re模块！）：

| 名称          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| re.IGNORECASE | 匹配时不区分大小写。                                         |
| re.MULTILINE  | 更改\^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) |
| re.DOTALL     | 更改.的含义，使它与每一个字符匹配（包括换行符\n）。          |
| re.VERBOSE    | 忽略表达式中的非转义空白并启用由#标记的注释。                |
| re.DEBUG      | 显示编译表达式的 debug 信息                                  |



##  平衡组&递归匹配

**使用场景**：匹配嵌套字符串，如匹配类中的大括号，HTML中的尖括号等



`(?'group')` 把捕获的内容命名为group,并压入堆栈(Stack) 

`(?'-group')` 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 

`(?(group)yes|no)` 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 

`(?!)` 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败



我们要做的是：

每碰到了左括号，就在压入一个"Open", 每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空；

不为空  -》证明左括号比右括号多，那匹配就应该失败。

正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配





## 正则表达式手册

### 表达式全集

|     字符     |                             描述                             |
| :----------: | :----------------------------------------------------------: |
|      \       | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“`n`”匹配字符“`n`”。“`\n`”匹配一个换行符。串行“`\\`”匹配“`\`”而“`\(`”则匹配“`(`”。 |
|      ^       | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“`\n`”或“`\r`”之后的位置。 |
|      $       | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“`\n`”或“`\r`”之前的位置。 |
|      *       | 匹配前面的子表达式零次或多次。例如，zo*能匹配“`z`”以及“`zoo`”。*等价于{0,}。 |
|      +       | 匹配前面的子表达式一次或多次。例如，“`zo+`”能匹配“`zo`”以及“`zoo`”，但不能匹配“`z`”。+等价于{1,}。 |
|      ?       | 匹配前面的子表达式零次或一次。例如，“`do(es)?`”可以匹配“`does`”或“`does`”中的“`do`”。?等价于{0,1}。 |
|    {*n*}     | *n*是一个非负整数。匹配确定的*n*次。例如，“`o{2}`”不能匹配“`Bob`”中的“`o`”，但是能匹配“`food`”中的两个o。 |
|    {*n*,}    | *n*是一个非负整数。至少匹配*n*次。例如，“`o{2,}`”不能匹配“`Bob`”中的“`o`”，但能匹配“`foooood`”中的所有o。“`o{1,}`”等价于“`o+`”。“`o{0,}`”则等价于“`o*`”。 |
|  {*n*,*m*}   | *m*和*n*均为非负整数，其中*n*<=*m*。最少匹配*n*次且最多匹配*m*次。例如，“`o{1,3}`”将匹配“`fooooood`”中的前三个o。“`o{0,1}`”等价于“`o?`”。请注意在逗号和两个数之间不能有空格。 |
|      ?       | 当该字符紧跟在任何一个其他限制符（*,+,?，{*n*}，{*n*,}，{*n*,*m*}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“`oooo`”，“`o+?`”将匹配单个“`o`”，而“`o+`”将匹配所有“`o`”。 |
|      .       | 匹配除“`\`*`n`*”之外的任何单个字符。要匹配包括“`\`*`n`*”在内的任何字符，请使用像“`(.|\n)`”的模式。 |
|  (pattern)   | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“`\(`”或“`\)`”。 |
| (?:pattern)  | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(|)`”来组合一个模式的各个部分是很有用。例如“`industr(?:y|ies)`”就是一个比“`industry|industries`”更简略的表达式。 |
| (?=pattern)  | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95|98|NT|2000)`”能匹配“`Windows2000`”中的“`Windows`”，但不能匹配“`Windows3.1`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern)  | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95|98|NT|2000)`”能匹配“`Windows3.1`”中的“`Windows`”，但不能匹配“`Windows2000`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |
| (?<=pattern) | 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?<=95|98|NT|2000)Windows`”能匹配“`2000Windows`”中的“`Windows`”，但不能匹配“`3.1Windows`”中的“`Windows`”。 |
| (?<!pattern) | 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?<!95|98|NT|2000)Windows`”能匹配“`3.1Windows`”中的“`Windows`”，但不能匹配“`2000Windows`”中的“`Windows`”。 |
|     x\|y     | 匹配x或y。例如，“`z|food`”能匹配“`z`”或“`food`”。“`(z|f)ood`”则匹配“`zood`”或“`food`”。 |
|    [xyz]     | 字符集合。匹配所包含的任意一个字符。例如，“`[abc]`”可以匹配“`plain`”中的“`a`”。 |
|    [^xyz]    | 负值字符集合。匹配未包含的任意字符。例如，“`[^abc]`”可以匹配“`plain`”中的“`p`”。 |
|    [a-z]     | 字符范围。匹配指定范围内的任意字符。例如，“`[a-z]`”可以匹配“`a`”到“`z`”范围内的任意小写字母字符。 |
|    [^a-z]    | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“`[^a-z]`”可以匹配任何不在“`a`”到“`z`”范围内的任意字符。 |
|      \b      | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“`er\b`”可以匹配“`never`”中的“`er`”，但不能匹配“`verb`”中的“`er`”。 |
|      \B      | 匹配非单词边界。“`er\B`”能匹配“`verb`”中的“`er`”，但不能匹配“`never`”中的“`er`”。 |
|     \cx      | 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“`c`”字符。 |
|      \d      |               匹配一个数字字符。等价于[0-9]。                |
|      \D      |              匹配一个非数字字符。等价于[^0-9]。              |
|      \f      |              匹配一个换页符。等价于\x0c和\cL。               |
|      \n      |              匹配一个换行符。等价于\x0a和\cJ。               |
|      \r      |              匹配一个回车符。等价于\x0d和\cM。               |
|      \s      | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 |
|      \S      |          匹配任何非空白字符。等价于[^ \f\n\r\t\v]。          |
|      \t      |              匹配一个制表符。等价于\x09和\cI。               |
|      \v      |            匹配一个垂直制表符。等价于\x0b和\cK。             |
|      \w      |    匹配包括下划线的任何单词字符。等价于“`[A-Za-z0-9_]`”。    |
|      \W      |        匹配任何非单词字符。等价于“`[^A-Za-z0-9_]`”。         |
|    \x*n*     | 匹配*n*，其中*n*为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“`\x41`”匹配“`A`”。“`\x041`”则等价于“`\x04&1`”。正则表达式中可以使用ASCII编码。. |
|    \*num*    | 匹配*num*，其中*num*是一个正整数。对所获取的匹配的引用。例如，“`(.)\1`”匹配两个连续的相同字符。 |
|     \*n*     | 标识一个八进制转义值或一个向后引用。如果\*n*之前至少*n*个获取的子表达式，则*n*为向后引用。否则，如果*n*为八进制数字（0-7），则*n*为一个八进制转义值。 |
|    \*nm*     | 标识一个八进制转义值或一个向后引用。如果\*nm*之前至少有*nm*个获得子表达式，则*nm*为向后引用。如果\*nm*之前至少有*n*个获取，则*n*为一个后跟文字*m*的向后引用。如果前面的条件都不满足，若*n*和*m*均为八进制数字（0-7），则\*nm*将匹配八进制转义值*nm*。 |
|    \*nml*    | 如果*n*为八进制数字（0-3），且*m和l*均为八进制数字（0-7），则匹配八进制转义值*nm*l。 |
|    \u*n*     | 匹配*n*，其中*n*是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 |



### 常用正则表达式

|         用户名          | /^[a-z0-9_-]{3,16}$/                                         |
| :---------------------: | ------------------------------------------------------------ |
|          密码           | /^[a-z0-9_-]{6,18}$/                                         |
|       十六进制值        | /^#?([a-f0-9]{6}\|[a-f0-9]{3})$/                             |
|        电子邮箱         | /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/ /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/ |
|           URL           | /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/ |
|         IP 地址         | /((2[0-4]\d\|25[0-5]\|[01]?\d\d?)\.){3}(2[0-4]\d\|25[0-5]\|[01]?\d\d?)/ /^(?:(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9]?)$/ |
|        HTML 标签        | /^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>\|\s+\/>)$/                 |
|     删除代码\\注释      | (?<!http:\|\S)//.*$                                          |
| Unicode编码中的汉字范围 | /^[\u2E80-\u9FFF]+$/                                         |













